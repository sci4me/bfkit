/// Represents any of the eight standard Brainfuck instructions:
///
/// * `+`
/// * `-`
/// * `>`
/// * `<`
/// * `,`
/// * `.`
/// * `[`
/// * `]`
///
/// as well as any instructions generated by optimizations.
#[derive(Debug, Clone)]
pub enum BrainfuckInstruction {
    /// Add represents some number of Brainfuck `+` instructions.
    Add(u8),
    /// Sub represents some number of Brainfuck `-` instructions.
    Sub(u8),
    /// Right represents some number of Brainfuck '>' instructions.
    Right(usize),
    /// Left represents some number of Brainfuck '<' instructions.
    Left(usize),
    /// Read represents a Brainfuck `,` instruction.
    Read,
    /// Write represents a Brainfuck `.` instruction.
    Write,
    /// Open represents a Brainfuck `[` instruction.
    Open,
    /// Close represents a Brainfuck `]` instruction.
    Close,
    /// Set is an instruction that assigns a cell in the tape to some value.
    Set(u8),
    /// ScanLeft represents the following sequence of Brainfuck instructions: `[<]`
    ScanLeft,
    /// ScanRight represents the following sequence of Brainfuck instructions: `[>]`
    ScanRight
}

/// Parses a sequence of BrainfuckInstructions from a string.
/// Ignores all non-Brainfuck characters.
pub fn parse_str(code: String) -> Vec<BrainfuckInstruction> {
    parse(&code.chars().collect::<Vec<char>>())
}

/// Parses a sequence of BrainfuckInstructions from a slice of characters.
/// Ignores all non-Brainfuck characters.
pub fn parse(code: &[char]) -> Vec<BrainfuckInstruction> {
    let mut result = Vec::new();

    let mut index = 0;
    while index < code.len() {
        let c = code[index];
        index += 1;
        match c {
            '+' => result.push(BrainfuckInstruction::Add(1)),
            '-' => result.push(BrainfuckInstruction::Sub(1)),
            '>' => result.push(BrainfuckInstruction::Right(1)),
            '<' => result.push(BrainfuckInstruction::Left(1)),
            ',' => result.push(BrainfuckInstruction::Read),
            '.' => result.push(BrainfuckInstruction::Write),
            '[' => result.push(BrainfuckInstruction::Open),
            ']' => result.push(BrainfuckInstruction::Close),
            _ => {
            }
        }
    }

    result
}
//! A parser from Brainfuck source code to sequences of BrainfuckInstructions.

/// Represents any of the eight standard Brainfuck instructions:
///
/// * `+`
/// * `-`
/// * `>`
/// * `<`
/// * `,`
/// * `.`
/// * `[`
/// * `]`
///
/// as well as any instructions generated by optimizations.
#[derive(Debug, Clone, PartialEq)]
pub enum BrainfuckInstruction {
    /// Add represents some number of Brainfuck `+` instructions.
    Add(u8),
    /// Sub represents some number of Brainfuck `-` instructions.
    Sub(u8),
    /// Right represents some number of Brainfuck '>' instructions.
    Right(usize),
    /// Left represents some number of Brainfuck '<' instructions.
    Left(usize),
    /// Read represents a Brainfuck `,` instruction.
    Read,
    /// Write represents a Brainfuck `.` instruction.
    Write,
    /// Open represents a Brainfuck `[` instruction.
    Open,
    /// Close represents a Brainfuck `]` instruction.
    Close,
    /// Set is an instruction that assigns a cell in the tape to some value.
    Set(u8),
    /// ScanLeft represents the following sequence of Brainfuck instructions: `[<]`
    ScanLeft,
    /// ScanRight represents the following sequence of Brainfuck instructions: `[>]`
    ScanRight,
}

/// Parses a sequence of BrainfuckInstructions from a string.
/// Ignores all non-Brainfuck characters.
///
/// # Arguments
///
/// * `code` - The Brainfuck source code to parse.
pub fn parse_str(code: String) -> Vec<BrainfuckInstruction> {
    parse(&code.chars().collect::<Vec<char>>())
}

/// Parses a sequence of BrainfuckInstructions from a slice of characters.
/// Ignores all non-Brainfuck characters.
///
/// # Arguments
///
/// * `code` - The Brainfuck source code to parse.
pub fn parse(code: &[char]) -> Vec<BrainfuckInstruction> {
    let mut result = Vec::new();

    let mut index = 0;
    while index < code.len() {
        let c = code[index];
        index += 1;
        match c {
            '+' => result.push(BrainfuckInstruction::Add(1)),
            '-' => result.push(BrainfuckInstruction::Sub(1)),
            '>' => result.push(BrainfuckInstruction::Right(1)),
            '<' => result.push(BrainfuckInstruction::Left(1)),
            ',' => result.push(BrainfuckInstruction::Read),
            '.' => result.push(BrainfuckInstruction::Write),
            '[' => result.push(BrainfuckInstruction::Open),
            ']' => result.push(BrainfuckInstruction::Close),
            _ => {}
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_str_parses_brainfuck_instructions() {
        let code = "++--,.[]<<>> [-]";

        let result = parse_str(code.to_string());

        assert_eq!(
            result,
            vec![
                BrainfuckInstruction::Add(1),
                BrainfuckInstruction::Add(1),
                BrainfuckInstruction::Sub(1),
                BrainfuckInstruction::Sub(1),
                BrainfuckInstruction::Read,
                BrainfuckInstruction::Write,
                BrainfuckInstruction::Open,
                BrainfuckInstruction::Close,
                BrainfuckInstruction::Left(1),
                BrainfuckInstruction::Left(1),
                BrainfuckInstruction::Right(1),
                BrainfuckInstruction::Right(1),
                BrainfuckInstruction::Open,
                BrainfuckInstruction::Sub(1),
                BrainfuckInstruction::Close
            ]
        );
    }

    #[test]
    fn parse_parses_brainfuck_instructions() {
        let code = "++--,.[]<<>> [-]";

        let result = parse(&code.chars().collect::<Vec<char>>());

        assert_eq!(
            result,
            vec![
                BrainfuckInstruction::Add(1),
                BrainfuckInstruction::Add(1),
                BrainfuckInstruction::Sub(1),
                BrainfuckInstruction::Sub(1),
                BrainfuckInstruction::Read,
                BrainfuckInstruction::Write,
                BrainfuckInstruction::Open,
                BrainfuckInstruction::Close,
                BrainfuckInstruction::Left(1),
                BrainfuckInstruction::Left(1),
                BrainfuckInstruction::Right(1),
                BrainfuckInstruction::Right(1),
                BrainfuckInstruction::Open,
                BrainfuckInstruction::Sub(1),
                BrainfuckInstruction::Close
            ]
        );
    }
}
